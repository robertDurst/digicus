[Contract]: SimpleAccount

[Interface]:
-() [init]
	* Inputs:
	{
		env: Env
		public_key: String
	}
	* Instructions:
		$
			{ instruction: evaluate, input: (env.storage), assign: METHOD_CALL_EXPRESSION_2, scope: 0 }
			{ instruction: evaluate, input: (METHOD_CALL_EXPRESSION_2.instance), assign: METHOD_CALL_EXPRESSION_1, scope: 0 }
			{ instruction: evaluate, input: (METHOD_CALL_EXPRESSION_1.has, DataKey::Owner), assign: CONDITIONAL_JUMP_ASSIGNMENT, scope: 0 }
			{ instruction: jump, input: (CONDITIONAL_JUMP_ASSIGNMENT, 1), scope: 0 }
			{ instruction: error_with_message, input: ("owner is already set"), scope: 1 }
			{ instruction: evaluate, input: (env.storage), assign: METHOD_CALL_EXPRESSION_7, scope: 0 }
			{ instruction: evaluate, input: (METHOD_CALL_EXPRESSION_7.instance), assign: METHOD_CALL_EXPRESSION_6, scope: 0 }
			{ instruction: evaluate, input: (METHOD_CALL_EXPRESSION_6.set, DataKey::Owner, public_key), scope: 0 }
		$
-() [__check_auth]
	* Inputs:
	{
		env: Env
		signature_payload: String
		signature: String
		_auth_context: List<Context>
	}
	* Instructions:
		$
			{ instruction: evaluate, input: (env.storage), assign: METHOD_CALL_EXPRESSION_3, scope: 0 }
			{ instruction: evaluate, input: (METHOD_CALL_EXPRESSION_3.instance), assign: METHOD_CALL_EXPRESSION_2, scope: 0 }
			{ instruction: evaluate, input: (METHOD_CALL_EXPRESSION_2.get, DataKey::Owner), assign: METHOD_CALL_EXPRESSION_0, scope: 0 }
			{ instruction: evaluate, input: (METHOD_CALL_EXPRESSION_0.unwrap), assign: public_key, scope: 0 }
			{ instruction: evaluate, input: (env.crypto), assign: METHOD_CALL_EXPRESSION_9, scope: 0 }
			{ instruction: evaluate, input: (signature_payload.into), assign: METHOD_CALL_ARG_2_6, scope: 0 }
			{ instruction: evaluate, input: (METHOD_CALL_EXPRESSION_9.ed25519_verify, public_key, METHOD_CALL_ARG_2_6, signature), scope: 0 }
		$
:[Interface]


[User Defined Types]:
* (DataKey)
{
	Owner: ()
}

:[User Defined Types]

