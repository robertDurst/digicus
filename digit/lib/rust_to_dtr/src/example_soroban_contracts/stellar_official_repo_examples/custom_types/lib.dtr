[Contract]: IncrementContract
[Functions]:
-() [increment]
* Inputs:
{
env: Env
incr: u32
}
* Output: u32
* Instructions:
$
{ instruction: evaluate, input: (env.clone), assign: 1_CALL_EXPRESSION_ARG, scope: 0 }
{ instruction: evaluate, input: (get_state, 1_CALL_EXPRESSION_ARG), assign: state, scope: 0 }
{ instruction: field, input: (state, count), assign: BINARY_EXPRESSION_LEFT, scope: 0 }
{ instruction: add_and_assign, input: (BINARY_EXPRESSION_LEFT, incr), scope: 0 }
{ instruction: field, input: (state, last_incr), assign: ASSIGN_EXPRESSION_LEFT, scope: 0 }
{ instruction: evaluate, input: (env.storage), assign: METHOD_CALL_EXPRESSION_3, scope: 0 }
{ instruction: evaluate, input: (METHOD_CALL_EXPRESSION_3.instance), assign: METHOD_CALL_EXPRESSION_2, scope: 0 }
{ instruction: evaluate, input: (METHOD_CALL_EXPRESSION_2.set, STATE, state), assign: METHOD_CALL_RESULT, scope: 0 }
{ instruction: field, input: (state, count), assign: Thing_to_return, scope: 0 }
{ instruction: Return, input: (Thing_to_return), scope: 0 }
$
-() [get_state]
* Inputs:
{
env: Env
}
* Output: State
* Instructions:
$
{ instruction: evaluate, input: (env.storage), assign: METHOD_CALL_EXPRESSION_4, scope: 0 }
{ instruction: evaluate, input: (METHOD_CALL_EXPRESSION_4.instance), assign: METHOD_CALL_EXPRESSION_3, scope: 0 }
{ instruction: evaluate, input: (METHOD_CALL_EXPRESSION_3.get, STATE), assign: METHOD_CALL_EXPRESSION_1, scope: 0 }
{ instruction: initialize_udt, input: (State, 0, 0), assign: 1_METHOD_CALL_ARG_0, scope: 0 }
{ instruction: evaluate, input: (METHOD_CALL_EXPRESSION_1.unwrap_or, 1_METHOD_CALL_ARG_0), assign: Thing_to_return, scope: 0 }
{ instruction: Return, input: (Thing_to_return), scope: 0 }
$
:[Functions]


[User Defined Types]:

* (State)
{
count: u32
last_incr: u32
}

:[User Defined Types]