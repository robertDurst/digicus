[Contract]: TtlContract

[Functions]:
-() [setup]
* Inputs:
{
env: Env
}
* Instructions:
$
{ instruction: evaluate, input: (env.storage), assign: METHOD_CALL_EXPRESSION_3, scope: 0 }
{ instruction: evaluate, input: (METHOD_CALL_EXPRESSION_3.persistent), assign: METHOD_CALL_EXPRESSION_2, scope: 0 }
{ instruction: evaluate, input: (METHOD_CALL_EXPRESSION_2.set, DataKey::MyKey, 0), assign: METHOD_CALL_RESULT, scope: 0 }
{ instruction: evaluate, input: (env.storage), assign: METHOD_CALL_EXPRESSION_3, scope: 0 }
{ instruction: evaluate, input: (METHOD_CALL_EXPRESSION_3.instance), assign: METHOD_CALL_EXPRESSION_2, scope: 0 }
{ instruction: evaluate, input: (METHOD_CALL_EXPRESSION_2.set, DataKey::MyKey, 1), assign: METHOD_CALL_RESULT, scope: 0 }
{ instruction: evaluate, input: (env.storage), assign: METHOD_CALL_EXPRESSION_3, scope: 0 }
{ instruction: evaluate, input: (METHOD_CALL_EXPRESSION_3.temporary), assign: METHOD_CALL_EXPRESSION_2, scope: 0 }
{ instruction: evaluate, input: (METHOD_CALL_EXPRESSION_2.set, DataKey::MyKey, 2), assign: METHOD_CALL_RESULT, scope: 0 }
$
-() [extend_persistent]
* Inputs:
{
env: Env
}
* Instructions:
$
{ instruction: evaluate, input: (env.storage), assign: METHOD_CALL_EXPRESSION_4, scope: 0 }
{ instruction: evaluate, input: (METHOD_CALL_EXPRESSION_4.persistent), assign: METHOD_CALL_EXPRESSION_3, scope: 0 }
{ instruction: evaluate, input: (METHOD_CALL_EXPRESSION_3.extend_ttl, DataKey::MyKey, 1000, 5000), assign: METHOD_CALL_RESULT, scope: 0 }
$
-() [extend_instance]
* Inputs:
{
env: Env
}
* Instructions:
$
{ instruction: evaluate, input: (env.storage), assign: METHOD_CALL_EXPRESSION_3, scope: 0 }
{ instruction: evaluate, input: (METHOD_CALL_EXPRESSION_3.instance), assign: METHOD_CALL_EXPRESSION_2, scope: 0 }
{ instruction: evaluate, input: (METHOD_CALL_EXPRESSION_2.extend_ttl, 2000, 10000), assign: METHOD_CALL_RESULT, scope: 0 }
$
-() [extend_temporary]
* Inputs:
{
env: Env
}
* Instructions:
$
{ instruction: evaluate, input: (env.storage), assign: METHOD_CALL_EXPRESSION_4, scope: 0 }
{ instruction: evaluate, input: (METHOD_CALL_EXPRESSION_4.temporary), assign: METHOD_CALL_EXPRESSION_3, scope: 0 }
{ instruction: evaluate, input: (METHOD_CALL_EXPRESSION_3.extend_ttl, DataKey::MyKey, 3000, 7000), assign: METHOD_CALL_RESULT, scope: 0 }
$
:[Functions]


[User Defined Types]:
* (DataKey)
{
MyKey
}

:[User Defined Types]